{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE NoImplicitPrelude #-}
module Control.Concurrent.Capataz.Internal.Supervisor where

import Protolude
import Data.Time.Clock (getCurrentTime)
import Control.Concurrent.Async (asyncWithUnmask)
import Control.Concurrent.STM.TVar (newTVarIO)
import Control.Concurrent.STM.TQueue (TQueue, newTQueueIO, readTQueue, writeTQueue)
import qualified Data.UUID.V4 as UUID

import Control.Concurrent.Capataz.Internal.Util (readCapatazStatusSTM, setProcessThreadName)
import Control.Concurrent.Capataz.Internal.Types
import qualified Control.Concurrent.Capataz.Internal.Process as Process


-- | Internal function that forks a worker thread on the Supervisor thread; note
-- this is different from the public @forkSupervisor@ function which sends a message
-- to the supervisor loop
forkSupervisor
  :: ParentSupervisorEnv -> SupervisorSpec -> Maybe (ProcessId, RestartCount) -> IO Supervisor
forkSupervisor parentEnv supervisorSpec mRestartInfo = do
  (supervisorId, restartCount) <- case mRestartInfo of
    Just (supervisorId, restartCount) -> pure (supervisorId, restartCount)
    Nothing                       -> (,) <$> UUID.nextRandom <*> pure 0

  supervisor <- supervisorMain parentEnv supervisorSpec supervisorId restartCount
  Process.notifyProcessStarted mRestartInfo env (SupervisorProcess supervisor)
  return supervisor

buildSupervisorEnv
  :: (CapatazEvent -> IO ())
  -> SupervisorId
  -> SupervisorSpec
  -> IO SupervisorEnv
buildSupervisorEnv notifyEvent supervisorId supervisorSpec@SupervisorSpec {..}  = do
  supervisorQueue <- newTQueueIO
  supervisorProcessMap <- newIORef mempty
  supervisorStatusVar <- newTVarIO Initializing
  return $ SupervisorEnv {..}


-- | This is the main thread loop of a "Supervisor" instance
supervisorLoop :: (forall b . IO b -> IO b) -> ParentSupervisorEnv -> SupervisorEnv -> IO ()
supervisorLoop
  unmask
  parentEnv@SupervisorEnv { supervisorId, supervisorName, supervisorNotify = notifyParentSupervisor }
  env@SupervisorEnv { supervisorId = processId, supervisorName = processName, supervisorSpec, supervisorStatusVar, supervisorGetNotification, notifyEvent }
  restartCount
  = do
    processThreadId <- myThreadId
    loopResult <-
      unmask
      $   try
      $   atomically
      $   (,)
      <$> readCapatazStatusSTM supervisorStatusVar
      <*> supervisorGetNotification

    case loopResult of
      Left  capatazError -> do
        result <- Process.handleProcessException unmask parentEnv supervisorSpec supervisorId restartCount
        notifyParentSupervisor result

      Right (status, message) -> case status of
        Initializing -> do
          eventTime <- getCurrentTime
          notifyEvent InvalidCapatazStatusReached
            { supervisorId
            , supervisorName
            , eventTime
            }
          supervisorLoop unmask parentEnv env restartCount

        Running -> do
          eContinueLoop <- try $ unmask $ handleSupervisorMessage env message
          case eContinueLoop of
            Left capatazError -> do
              result <- Process.handleProcessException unmask parentEnv supervisorSpec supervisorId restartCount
              notifyParentSupervisor result

            Right continueLoop
              | continueLoop -> supervisorLoop unmask parentEnv env restartCount
              | otherwise -> do
                eventTime <- getCurrentTime
                notifyEvent ProcessTerminated
                  { supervisorId
                  , supervisorName
                  , eventTime
                  , processId
                  , processName
                  , processThreadId
                  , terminationReason = "Supervisor normal termination"
                  }

        Halting ->
          -- Discard messages when halting
          return ()

        Halted ->
          -- Discard messages when halted
          return ()


-- | Decorates the given @IO ()@ sub-routine with failure handling
supervisorMain :: ParentSupervisorEnv ->  SupervisorSpec -> WorkerId -> RestartCount -> IO Supervisor
supervisorMain
  parentEnv@SupervisorEnv { supervisorQueue = parentQueue, notifyEvent }
  supervisorSpec@SupervisorSpec { supervisorName }
  supervisorId
  restartCount
  = do
    supervisorCreationTime <- getCurrentTime
    supervisorQueue <- newTQueueIO
    supervisorEnv   <- buildSupervisorEnv notifyEvent supervisorId

    supervisorAsync <- asyncWithUnmask $ \unmask -> do
        setProcessThreadName supervisorId supervisorName
        supervisorLoop unmask parentEnv undefined restartCount

    return Supervisor
      { supervisorId
      , supervisorName
      , supervisorAsync
      , supervisorSpec
      , supervisorCreationTime
      }
